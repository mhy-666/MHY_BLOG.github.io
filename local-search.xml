<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>软件工程中过程模型的比较分析（软工课程三大板块之第一板块）</title>
    <link href="/2021/10/14/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%AD%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83%E5%88%86%E6%9E%90%EF%BC%88%E8%BD%AF%E5%B7%A5%E8%AF%BE%E7%A8%8B%E4%B8%89%E5%A4%A7%E6%9D%BF%E5%9D%97%E4%B9%8B%E7%AC%AC%E4%B8%80%E6%9D%BF%E5%9D%97%EF%BC%89/"/>
    <url>/2021/10/14/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%AD%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83%E5%88%86%E6%9E%90%EF%BC%88%E8%BD%AF%E5%B7%A5%E8%AF%BE%E7%A8%8B%E4%B8%89%E5%A4%A7%E6%9D%BF%E5%9D%97%E4%B9%8B%E7%AC%AC%E4%B8%80%E6%9D%BF%E5%9D%97%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>在我们的教材《软件工程-实践者的研究方法》中，作者pressman在一开始就提出了关于软件工程核心的观点：</p><p>软件工程=方法+工具+过程</p><p>等式右边的三个被称为软件工程核心的三要素。可看出，过程在软件工程中是一个非常重要的元素，它代表着整个软件开发的生命周期，因此研究清楚其中传统的过程模型就很有意义。</p><p><img src="file:///C:/AppData/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg" alt="img"></p><p>我们选择五种传统的过程模型：瀑布模型，增量模型，原型模型，螺旋模型以及统一过程模型。下面首先是对各个模型进行的比较分析，我们分析的规则是按照针对每一个模型来进行的。</p><p>1瀑布模型：</p><p>1.1概述</p><p>瀑布模型最经典的软件工程过程模型，它的定义是将软件生存周期中的各个活动规定为依线性顺序连接的若干阶段的模型，包括需求分析、设计、编码、测试、运行和维护。而每一个阶段都有一个产出。如下图所示：</p><p><img src="file:///C:/AppData/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png" alt="img"></p><p>它规定了由前至后、相互衔接的固定次序，如同瀑布流水逐级下落，是一种使用广泛，以文档为驱动的模型。瀑布模型一直被用来规范软件开发活动，很多其它模型都是在瀑布模型基础上的改进。</p><p>1.2与其他模型相比的特点</p><p>1）为项目提供了按阶段划分的检查点。当前一阶段完成后，您只需要去关注后续阶段。</p><p>2）需要明确的需求，基本上以项目的文档控制为手段对整个开发过程进行指导，所以它是以文档作为驱动、适合于软件需求很明确的软件项目的模型</p><p>3）软件开发过程与软件生命周期是一致的，也称经典生命周期模型它提供了一个模板，这个模板使得分析、设计、编码、测试和支持的方法可以在该模板下有一个共同的指导。</p><p>优点：</p><p>1）每个阶段都有与其相关联的里程碑和可交付产品；</p><p>2）每个阶段结束前完成文档审查,及早改正错误。</p><p>3）阶段间具有顺序性和依赖性；</p><p>4）引入了推迟实现的观点</p><p>缺点：</p><p>因为是最初的软件过程模型，所以缺点也是比较多的，这也为后来其他模型的出现提供了可能。</p><p>1）早期的错误可能要等到开发后期的测试阶段才能发现，可能带来严重的后果；</p><p>2）不能适应需求不明确和需求的变化；</p><p>3）不能反映实际的开发方式，软件开发需要迭代。</p><p>4）每阶段的划分固定，阶段之间产生大量的文档，极大地增加了工作量。</p><p>5）用户只有等到整个过程的末期才能见到开发成果，从而增加了开发风险。</p><p>6）不能适应用户需求的变化。</p><p>1.3适用范围</p><p>由前面的特点介绍可知，瀑布模型适用于系统需求明确且稳定、技术成熟、工程管理较严格的场合，适用于需求确定，无大的需求变更，工作能够采用线性的方式完成的软件。如银行金融、国防、航天、医疗等大型工业级系统。</p><p>2增量模型：</p><p>2.1概述</p><p>增量模型也称渐增模型。使用增量模型开发软件时，把软件产品作为一系列的增量构件来设计、编码、集成和测试。在整体上按照瀑布模型的流程实施项目开发，以方便对项目的管理；但在软件的实际开发中，则将软件系统按功能分解为许多增减构件，并以构件为单位逐个地创建与交付，直到全部增量构件创建完成，并都被集成到系统之中交付用户使用。用图形表示如下图：</p><p><img src="file:///C:/AppData/AppData/Local/Temp/msohtmlclip1/01/clip_image006.jpg" alt="img"></p><p>2.2与其他模型相比的特点</p><p>1）与瀑布模型的目标是一次就把一个满足所有需求的产品提交给用户相比，增量模型则是把整个软件产品分解成许多个增量构件，分批地逐步向用户提交产品</p><p>2）把软件产品分解成增量构件时，必须遵守的约束条件是：当把新构件集成到现有构件中时，所形成的产品必须是可测试的</p><p>3）把瀑布模型的顺序特征与后面提到的原型模型的迭代特征相结合，将软件看作一系列相互联系的增量，在开发过程的各次迭代中，每次完成其中的一个增量</p><p>4）增量模型把软件作为一系列增量来设计、编码、测试和交付，对于每一个增量而言，它们各自的开发可用瀑布模型或者原型模型</p><p>5）增量模型是一种进化式的开发过程，往往第一个增量是核心产品。</p><p>优点：</p><p>1）软件能够更早投入市场，能在短时间内向用户提交可完成部分工作的产品。</p><p>2）逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品，从而减少一个全新的软件可能给客户组织带来的冲击。</p><p>3）将待开发的软件系统模块化，可以分批次地提交软件产品，使用户可以及时了解软件项目的进展，开放式体系结构，便于维护</p><p>4）以组件为单位进行开发降低了软件开发的风险。一个开发周期内的错误不会影响到整个软件系统</p><p>5）开发顺序灵活。开发人员可以对组件的实现顺序进行优先级排序，先完成需求稳定的核心组件。当组件的优先级发生变化时，还能及时地对实现顺序进行调整</p><p>缺点：</p><p>1）在把每个新的增量构件集成到现有软件体系结构中时，必须不破坏原来已经开发出的产品。</p><p>2）软件体系结构必须是开放的，必须把软件的体系结构设计得便于按这种方式进行扩充，向现有产品中加入新构件的过程必须简单、方便。</p><p>3）从某种意义上说，增量模型本身是自相矛盾的。它一方面要求开发人员把软件看作一个整体，另一方面又要求开发人员把软件看作构件序列，每个构件本质上都独立于另一个构件。这对开发人员的技术协调能力是一个很大的挑战，对于项目的进展也是一个阻碍。</p><p>2.3适用范围</p><p>适用于软件开发中需求可能发生变化、具有较大风险、或者希望尽早入市场的项目。这些软件系统必须是模块化程度高，并且能按模块分批次交付的。</p><p>3原型化模型：</p><p>3.1概述</p><p>根据运用原型的目的和方式不同，可以将原型模型分为快速原型模型（抛弃型）和原型进化模型（渐进型），我们这里只讨论后者，即演进模型下的原型化模型。</p><p>原型化模型是指，开发人员对用户提出的问题进行总结，就系统的主要需求取得一致意见后，开发出一个原型并运行之，然后反复对原型进行修改，使之逐步完善，直到用户对系统完全满意为止。</p><p>原型化开发是一种能使某些类型风险降至最低的方法。为了降低交付给用户的产品不能满足用户需要的风险，一种行之有效的方法是在需求分析阶段快速构建一个原型。在后续的阶段中也可以通过构造适当的原型来降低某些技术风险。</p><p>3.2与其他模型相比的特点</p><p>1）原型进化模型将原型用于开发的全过程，原型由最基本的核心开始，逐步增加新的功能和新的需求，反复修改反复扩充，最后发展为用户满意的最终系统。</p><p>2）原型进化模型能够适应软件需求的中途变更，它是通过不断发布新的软件版本而使软件逐步完善的，因此，这种开发模式适合于用户急需的软件产品开发。</p><p>优点：</p><p>1）能够快速地向用户交付可以投入实际运行的软件成果，并能够很好地适应软件用户对需求规格的变更。</p><p>2）需求表达清楚，减少需求不明确带来的风险。</p><p>缺点：</p><p>1）不能提供明确的里程碑管理，随着开发过程中版本的快速更新，项目管理、软件配置管理会变得复杂起来，管理者难以把握开发进度。因此，对于大型软件项目，原型进化模型缺乏有效的管理规程。</p><p>2）开发过程中软件版本的快速变更、快速建立起来的系统加上连续的修改可能导致原型质量低下，可能损伤软件的内部结构，使其缺乏整体性和稳定性。设计者在质量和原型中进行折中，</p><p>3）用于反映软件版本变更的文档也有可能跟不上软件的变更速度。这些问题必将影响到今后软件的维护。</p><p>3.3适用范围</p><p>适合开发大型信息系统、系统的具体需求不明确或者开发者不确定技术方案或者算法是</p><p>否可行的情况。</p><p>4螺旋模型：</p><p>4.1概述</p><p>螺旋模型是结合了瀑布模型的系统化特点和快速原型迭代过程特点以及风险分析三者于一身的模型。它的开发过程分为多个迭代，它在每一个迭代中的主要工作分为四部分</p><p>1） 制定计划：确定软件目标，选定实施方案，弄清项目开发的限制条件；</p><p>2） 风险分析：分析评估所选方案，考虑如何识别和消除风险；</p><p>3） 实施工程：实施软件开发和验证；</p><p>4） 客户评估：评价开发工作，提出修正建议，制定下一步计划。</p><p>而这样四个工作是要迭代多个阶段。</p><p>4.2与其他模型相比的特点</p><p>1）强调了其他模型所忽视的风险分析，特别适合于大型复杂的系统。</p><p>2）螺旋模型支持用户需求的动态变化，为用户参与软件开发的所有关键决策提供了方便.</p><p>3）在螺旋模型中维护只是模型的另一个周期，在维护和开发之间并没有本质区别。</p><p>优点：</p><p>1）螺旋模型原型可作为继续开发的基础，螺旋模型特别强调原型的可扩充性和可修改性，原型的进化贯穿整个软件生存周期，这将有助于目标软件的适应能力，支持用户需求的动态变化。</p><p>2）螺旋模型为项目管理人员及时调整管理决策提供了方便，进而可降低开发风险。</p><p>3）螺旋模型将质量目标放在首位对可选方案和约束条件的强调有利于已有软件的重用，也有助于把软件质量作为软件开发的一个重要目标。</p><p>4）减少了多个测试（浪费资金）或测试不足（产品故障多）所带来的风险。</p><p>缺点：</p><p>1）如果每次迭代的效率不高，致使迭代次数过多，将</p><p>会增加成本并推迟提交时间；</p><p>2）使用该模型需要有相当丰富的风险评估经验和专门知识，要求开发队伍水平较高，否则会带来更大风险螺旋模型强调风险分析，但要求许多客户接受和相信这种分析，并做出相关反应是不容易的，因此，</p><p>　　3）如果执行风险分析将大大影响项目的利润，那么进行风险分析毫无意义，因此，螺旋模型只适合于大规模软件项目。</p><p>　　4）软件开发人员应该擅长寻找可能的风险，准确地分析风险，否则将会带来更大的风险</p><p>4.3适用范围</p><p>适用于需求不明确或者需求可能发生变化的大型复杂的软件系统，或者内部的大规模软件开发。</p><p>5统一过程模型：</p><p>5.1概述</p><p>统一过程模型是一种“用例和风险驱动，以架构为中心、迭代并且增量”的开发过程，由 UML 方法和工具支持。迭代的意思是将整个软件开发项目划分为许多个小的“袖珍项目”，每个“袖珍项目”都包含正常软件项目的所有元素：计划、分析和设计、构造、集成和测试，以及内部和外部的发布。</p><p>5.2与其他模型相比的特点</p><p>构建出了四大开发阶段：</p><p>1）初始阶段 大体上的构想，业务案例，范围，和模糊评估。定义系统的业务模型，确定系统的范围。完成后建立目标里程碑</p><p>2）细化阶段 已精化的构想、核心架构的迭代实现、高风险的解决、确定大多数需求和范围以及进行更为实际的评估。完成系统的体系结构设计，完成系统开发计划。建立结构里程碑</p><p>3）构建阶段 对遗留下的风险较低和比较简单的元素进行迭代实现，准备部署。构造产品，并继续演进需求、体系结构和计划，直到产品完成</p><p>4）移交阶段 进行系统部署，系统测试，最终移交给用户。最后建立发布里程碑</p><p>表 RUP的四个阶段</p><p>每个阶段都由一个或多个迭代组成。每个迭代都要针对不同的业务用例或系统用例进行细化和实现</p><p>统一过程模型提出了9个工作流：</p><p>1）6个核心工作流：业务建模、需求、分析设计、实现、测试、部署。</p><p>2）3个核心支持工作流：配置与变更管理、项目管理和环境</p><p>5.3适用范围</p><p>可用于不同类型的应用系统、各种不同的应用领域、各种不同类型的组织、各种不同功能和规模的项目。这是因为Rational Unified Process 在建立简洁和清晰的过程结构为开发过程家族提供通用性。并且，它可以变更以容纳不同的情况。它还包含了开发工具包，为配置适应特定组织机构的开发过程提供了支持。</p><p>敏捷开发方法</p><p>软件工程的核心就是，围绕软件开发过程，产生的方法学和工具。方法学包含两个部分：过程和方法。</p><p>过程：在软件项目的生命周期内，要遵循的步骤。</p><p>方法：过程中的每个步骤要如何进行。</p><p>在2001年2月，17位编程大师发表敏捷软件开发宣言：</p><p>1）个体和交互胜过过程和工具</p><p>2）可以工作的软件胜过面面俱到的文档</p><p>3）客户合作胜过合同谈判</p><p>4）响应变化胜过遵循计划</p><p>虽然右边的项有价值，但我们更重视左边的项。</p><p>这其中要说明的是，敏捷开发不是具体方法、框架或过程，是一套价值观和原则。在这里，我们挑选介绍的敏捷开发方法是scrum。</p><p>1 scrum的概述</p><p>首先来看scrum的定义：Scrum 是用于开发、交付和持续支持复杂产品的一个框架，是一个增量的、迭代的开发过程。在这个框架中，整个开发过程由若干个短的迭代周期组成，一个短的迭代周期称为一个Sprint，每个Sprint的建议长度是一至四周。</p><p>下面对这个定义进行解释，首先我们需要明白，敏捷开发(Agile Development)是一种以人为核心、迭代、循序渐进的开发方法。而scrum就是在它的基础上偏重于过程进行的开发，Scrum单词来源于澳式橄榄球的争球场景，大家头碰头，肩并肩，共同进退，这样就是Scrum方法的一种精神。像打橄榄球一样，Scrum就是这样的一个开发流程，运用该流程，你就能看到你团队高效的工作。</p><p>2 scrum的框架</p><p>我们在理解Scrum的过程中只要牢记5个数字1 3 3 5 5即可：</p><p>1：一张流程图；3：三个工件；3：三个角色；5：五个活动；5：五个价值</p><p>2.1流程图</p><p>首先是流程图，这张流程图我们可以分成3个部分来看：</p><p><img src="file:///C:/AppData/AppData/Local/Temp/msohtmlclip1/01/clip_image008.jpg" alt="img"></p><p>第一部分是左边的叫做”需求池”，就是我们常说的sprint backlog，里面的每个需求都是有优先级的，这个需求池由前面两个产品backlog和springt计划会议组成。</p><p>第二部分是2个圈，大圈我们一般叫做Sprint（冲刺）/Iteration（迭代），一般一个周期是30天，推荐周期是2~4周。小圈的周期是24H，一般就是一个站立会（Standup Meeting）</p><p>第三部分是最右边部分一个完成的箱子样的东西就是我们常说的产品增量，通俗一点就是输出。一般是可运行的软件。</p><p>2.2三个工件</p><p>这三个工件就是上面流程图中的三个重要名词</p><p>1）产品Backlog（Product Backlog）</p><p>2）SprintBacklog</p><p>3）产品增量（Increment）</p><p>我们在第四部分应用举例中会对它们进行进一步的介绍。</p><p>2.3三个角色</p><p>一般Scrum团队有三个角色，分别如下：</p><p>1）PO：Product Owner；我们常称为产品经理或产品的拥有者</p><p>2）Team：研发团队</p><p>3）Scrum Master：敏捷教练</p><p>这三个角色我们在第三部分如何理解scrum和第四部分应用举例中对他们进行详细的介绍。</p><p>2.4五个活动</p><p>0）第一个活动是Sprint，它本身是一个活动，包含四个活动，而这四个活动其实就是四个会议，如下：</p><p>1）Planning Game：规划会议。一般在每个Sprint前召开。</p><p>2）Standup Meeting：就是我们常说的站立会。就是流程中小圈的位置，间隔24小时，即每天召开。</p><p>3）Demo Meeting：演示会。在我们输出成果物前需要进行演示，确定哪些有价值的功能作为本次迭代的输出，进行上线发布。</p><p>4）Retrospective Meeting：回顾会。一般在一个Sprint完了后进行总结反省。也是体现敏捷精神中的一个重要环节。</p><p>2.5五个价值</p><p>在 Agile Software Development with Scrum一书中指出，Scrum的核心价值观是：承诺、专注、公开、敬重和勇气。它提倡自我管理、涌现机制、可视性和评估/适应循环的根本原则。 </p><p>   1）承诺（Commitment）— 承诺不只是把一项工作分配给团队，也不是简单的答应去完成。它是建立在目标之 上的来自内心的接受和应许，这里只有“做”和“不做”，没有“让我试试” </p><p>2）专注（Focus）— 像邮件和不相关的会议就是很常见的一些分散注意力的事情，我们需要做得是不转移注意力，把精力全部集中在承诺的事务上</p><p>3）公开（Openness）— 保持一直让任何有兴趣的人员都可以在墙上、wiki页面或者仪表盘工具上获知项目当前状况，能够了解多少功能已经完成，哪些正在做，每次迭代和发布的目标是什么</p><p>4）尊重（Respect）— 每个团队成员都必须被尊重的看待，大家一起指定工作规范（working agreements）</p><p>5）勇气（Courage）— 为了接受并负责任的交付产品，团队成员必须有足够的勇气来对大家说“不”，比如不能承诺时，对纳入sprint的故事说“不”等.</p><p>3如何理解scrum</p><p>Scrum的核心在于迭代，如上面提到的，整个过程只有三个角色。</p><p>产品负责人的职责是利用产品backlog，督促团队优先开发具有价值的功能，并在其基础上继续 开发。产品负责人必须频繁检视产品代开发需求的优先级，以便将最具价值的功能安排在下一个迭代中完成。</p><p>团队的责任是开发软件功能，他们是自组织团队，团队 所有成员对每一次迭代和整个项目共同负责，不单做考核。</p><p>Scrum Master则需要对Scrum过程负责，向所有项目参与者讲授Scrum方法，负责实施Scrum，确保它既符合企业文化，又能交付预期利益，还需督促 全体成员遵从Scrum规则和实践。</p><p>启动Scrum项目所需的最简约计划包括：一个需求池及产品Backlog这其实就是我们提到的三个工件中的前两个。</p><p>需求池又叫做愿景描述，它的项目开发原因和预期目标。愿景可能描述商业运作方式将发生哪些改变，主要特性和功能如何为客户创造收益，以及对市场的预期影响。</p><p>产品backlog将定义交付愿景时，系统应满足的功能性和非功能性需求，它需事先划分优先级并经过初始预估（预估的目的是了解每个需求自身及相对与其他需求的规模）。</p><p>最后我们的产出就是第三个工件产品输出。</p><p>4 Scrum应用举例</p><p>在Sprint第一天召开sprint计划会议，这个会议分为两部分，计划会议1由PO、SM和Team参加，主要是从产品backlog中挑选出需要放 到当前sprint下的既定产品backlog，然后由SM、Team参加计划会议2，把既定产品backlog的故事拆分成任务进行估算，PO也可以一 起参加这个部分来了解具体的开发细节。sprint周期在spirnt计划会议2正式开始。</p><p>开发过程中，团队每天召开每日站会（Daily Scrum），沟通团队成员间工作进度和进行任务协调。Sprint周期结束时，需要召开Sprint评审会议，由团队向产品负责人和其他利益相关者展示当前sprint周期内的产品开发情况。</p><p>产品负责人根据团队这次 Sprint 所发布的版本，评审相关的 Backlog 中的问题，检查是否已达到 Sprint 的目标。评审会议结束后会进行回顾会议，通过总结以往的实践经验来提高团队生产力。</p><p>这样就是一个完整的通过scrum开发的应用案例。可以看出，与传统开发方法相比，scrum有着其独特的优势，尤其适用于需求变化比较快，对未来产品规划并不明朗，市场变化比较快，创新型的，探索性、试错成本低的项目。</p>]]></content>
    
    
    
    <tags>
      
      <tag>软件工程|过程模型|敏捷方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划之状态转移方程应用</title>
    <link href="/2021/04/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B%E5%BA%94%E7%94%A8/"/>
    <url>/2021/04/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>今天对于状态转移方程有了自己的一些理解，下面这道题就是自己亲手写出来的，怎么说呢，感觉还是蛮自豪的。<br>/*<br>给定一些硬币的面额，求最少可以用多少颗硬币组成给定的金额。<br>输入输出样例<br>输入一个一维整数数组，表示硬币的面额；以及一个整数，表示给定的金额。输出一个整数，<br>表示满足条件的最少的硬币数量。若不存在解，则返回 - 1。<br>Input : coins = [1, 2, 5], amount = 11<br>Output : 3<br>在这个样例中，最少的组合方法是 11 = 5 + 5 + 1。<br><em>/<br>#include <iostream><br>#include<vector><br>#include<cmath><br>#include&lt;math.h&gt;<br>using namespace std;<br>//首先，dp[j]代表的是在给定金额为j的情况之下，所用的最少硬币数。<br>//显然，这是一个完全背包问题，构造dp为一维数组，内层选择从左到右迭代（正序）<br>int min(int a, int b)<br>{<br>    if (a &gt;= b)return b;<br>    else return a;<br>}<br>int lc322(vector<int>&amp;coins,int amount)<br>{<br>    vector<int>dp(amount+1, 10000);<br>    dp[0] = 0;<br>    for (const int&amp; i : coins)<br>    {<br>        for (int j = i; j &lt;= amount; j++)<br>        {<br>            dp[j] = min(dp[j], dp[j - i] + 1);<br>        }<br>    }<br>    return dp[amount];<br>}<br>/*int main()<br>{<br>    int n, amount;<br>    cin &gt;&gt; n &gt;&gt; amount;<br>    vector<int>coins(n, 0);<br>    for (int i = 0; i &lt; n; i++)<br>    {<br>        cin &gt;&gt; coins[i];<br>    }<br>    cout&lt;&lt;lc322(coins, amount);<br>}</int></int></int></cmath></vector></iostream></em>/</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>自制（手抄）操作系统--xv6学习笔记前言</title>
    <link href="/2021/04/20/%E8%87%AA%E5%88%B6%EF%BC%88%E6%89%8B%E6%8A%84%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%89%8D%E8%A8%80/"/>
    <url>/2021/04/20/%E8%87%AA%E5%88%B6%EF%BC%88%E6%89%8B%E6%8A%84%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%89%8D%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<p>  发现自己一直以来的学习都有一个矛盾：动手的时候发现理论知识不太会，告诫自己不要好高骛远，先沉下心来钻研基础理论；等开始钻研基础理论时，又发现自己怎么也不能深入理解，并且学过就忘，又想起警世格言“learning by doing（coding/programing）”，遂又反过头来继续动手操作。如此反复，陷入一个奇妙的恶性循环，现在想来，我愿称这种学习为“混沌学习理论”。这样的学习方法蕴含的思想对吗，很难说不对；有效吗，很难称得上有效，尤其是这样的学习方法让自己感到持久性的痛苦和持久性的生理不适。那么，问题出在了哪里呢？我今天顿悟：理论与实践切换周期过长，切换频率过慢。什么意思，简而言之，就是字面理解，在各自方面投入的学习时间过长，没有把握好一个完整的理论+实践学习的周期。话说到这里，解决方法也就显而易见，加快切换速度，缩短切换周期呗。<br>  以为这样就完了吗，并没有。怎么分配呢，是平均吗，我觉得不是，至少在现在的我，在今天的我看来不是（毕竟还没有真正付诸实践）。我认为在入门阶段应该重动手，轻理论。入门之后的事情我也没接触到，不好说。注意，这里我指的是学习任意一门知识，都是按照这样来入门。<br>  总之今天就先这样，要开始做xv6的实验了，在实践过程中再有什么新的感悟或者修正再讲吧。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于背包问题及其拓展应用</title>
    <link href="/2021/04/19/%E5%85%B3%E4%BA%8E%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95%E5%BA%94%E7%94%A8/"/>
    <url>/2021/04/19/%E5%85%B3%E4%BA%8E%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>背包问题是一个经典的动态规划问题。分为完全背包和01背包。每一种背包对应着两种解法，时间复杂度和空间复杂度分别为&lt;o(nw),o(nw)&gt;和&lt;o(nw),o(w)&gt;，可见差异在于空间复杂度。造成差异的原因是dp容器后者比前者少了一个维度。此外，两种背包问题它们后一种解法各自的迭代顺序不同；前一种解法的状态转移方程不同。以上就是两种背包问题本身的所有差异以及各自对应的两种解法的所有差异。<br>从个人来讲，我不喜欢第一种解法（不论是哪种背包问题），因为宏观上状态转移方程很好理解，但是for循环过程不好理解。我更喜欢后一种，既降低了空间复杂度，也在过程中更容易理解。以下是三种解法，前两个是01背包问题的第一第二解法，第三种是完全背包问题的第二解法。顺带一提，完全背包问题的第一解法的状态转移方程为dp[i][j]=max(dp[i-1][j],dp[i][j-w]+v)</p><p>// 背包问题.cpp : 此文件包含 “main” 函数。程序执行将在此处开始并结束。<br>//</p><p>#include <iostream><br>#include <vector><br>#include <cmath><br>#include &lt;math.h&gt;<br>using namespace std;<br>int max(int a, int b)<br>{<br>    if (a &gt;= b)return a;<br>    else return b;<br>}<br>void knapback(int N,int W,vector<int>&amp;value,vector<int>&amp; weight)<br>{</int></int></cmath></vector></iostream></p><pre><code>vector&lt;vector&lt;int&gt;&gt;dp(N+1, vector&lt;int&gt;(W+1,0));for (int i = 1; i &lt;= N; i++)&#123;    int w = weight[i];    int v = value[i];    for (int j = 1; j &lt;= W; j++)    &#123;        if (j &gt; w)            dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w] + v);        else            dp[i][j] = dp[i - 1][j];    &#125;&#125;cout &lt;&lt; dp[N][W];</code></pre><p>}<br>void knapback_2(int N, int W, vector<int>&amp; value, vector<int>&amp; weight)<br>{<br>    vector<int>dp(W + 1,  0);<br>    for (int i = 1; i &lt;= N; i++)<br>    {<br>        int w = weight[i]; int v = value[i];<br>        for (int j = W; j &gt;= w; j–)<br>        {<br>            dp[j] = max(dp[j], dp[j - w] + v);<br>        }<br>    }<br>    cout &lt;&lt; dp[W];<br>}</int></int></int></p><p>void knapback_3(int N, int W, vector<int>&amp; value, vector<int>&amp; weight)//完全背包问题<br>{<br>    vector<int>dp(W + 1, 0);<br>    for (int i = 1; i &lt;= N; i++)<br>    {<br>        int w = weight[i]; int v = value[i];<br>        for (int j = w; j &lt;= W; j++)<br>        {<br>            dp[j] = max(dp[j], dp[j - w] + v);<br>        }<br>    }<br>    cout &lt;&lt; dp[W];<br>}<br>/*测试用例<br>34 10<br>2 7 3 4 8 5 8 6 4 16<br>15 25 8 9 15 9 13 9 6 14<br>34 10<br>2 8 4 4 8 7 8  5 16 16<br>15 25 9 9 15 12 12 6 14 9*/<br>int main()<br>{<br>    int W, N;<br>    cin &gt;&gt; W &gt;&gt; N;<br>    vector<int> weight(N + 1);<br>    vector<int> value(N + 1);<br>    for (int i = 1; i &lt;= N; i++)<br>    {<br>        cin &gt;&gt; weight[i];</int></int></int></int></int></p><pre><code>&#125;for (int i = 1; i &lt;= N; i++)&#123;    cin &gt;&gt; value[i];&#125;knapback_3(N,W,value,weight);</code></pre><p>}<br>这里面有一些自己在编程过程中犯的错误，还有一些技巧。<br>1.N+1,W+1<br>这里将vector的大小设为+1是因为更好的理解，以后自己也尽量不要去考虑0号元素，认为它是空就好了，同时编码的时候要注意for循环i的初始值和结束值。<br>2.vector的赋值问题<br>3.完全背包问题第二解法更新dp是正序遍历，为了是能够将平均价值最多的物品找出来。<br>4.01背包问题的第一解法内层循环分为j&gt;=w和j&lt;w两种情况，j&lt;w时直接把上一个i-1的dp赋值过去就好</p><p>自己还有一些疑惑，比如完全背包问题直接找平均价值最高的物品不就好了吗，为什么要这么麻烦？</p><p>#pragma once<br>/<em>题目描述<br>给定一个正整数数组，求是否可以把这个数组分成和相等的两部分。<br>输入输出样例<br>输入是一个一维正整数数组，输出时一个布尔值，表示是否可以满足题目要求。<br>Input : [1, 5, 11, 5]<br>Output : true<br>在这个样例中，满足条件的分割方法是[1, 5, 5] 和[11]。</em>/</p><p>#include <iostream><br>#include<vector><br>#include<cmath><br>#include&lt;math.h&gt;<br>using namespace std;<br>bool if416(vector<int>&amp;number,int n)<br>{</int></cmath></vector></iostream></p><pre><code>int target=0;for (int i = 1; i &lt; number.size(); i++)&#123;    target += number[i];&#125;if (target % 2)return false;target = target / 2;vector&lt;int&gt;dp(target + 1, 0);dp[0] = 1;for (int i = 1; i &lt;= n; i++)&#123;    int v = number[i];    for (int j = target; j &gt;= v; j--)    &#123;        dp[j] = dp[j] || dp[j - v];    &#125;&#125;cout &lt;&lt; dp[target];</code></pre><p>}<br>/*<br>4<br>1 5 5 11<br>*/</p><p>经过了这道题，我想试着总结一下背包问题的应用，或者说是神奇之处：它可以把n个有重量物品中任意x个物品的属性组合在一起，并把所有组合情况都遍历一遍。背包也好，上面这道题也好，所求的其实都是在某种重量约束下这些组合属性的限制条件，比如背包就是x个有重量物品，属性为价值，重量约束为不超过w，限制条件是x个物品的属性最大，dp为最大价值，过程为从0到w的所有最大价值。再比如上面这道题，就是x个有大小（重量）的数（物品），没有属性，重量约束为等于target，dp为真假，过程为从0到target的所有真假。</p><p>——-4.20补充<br>一定要知道自己构造的dp到底代表的什么，比如背包问题，dp[i][j]代表的是对于遍历到第i个物品时，背包所容纳的重量不超过j的情况下装入物品的最大价值，而第二解法的dp[j]则代表背包所容纳的重量不超过i的情况下装入物品的最大价值。再比如417，dp[j]代表的是是否存在和为j的情况。<br>下面这道题，dp[i][j]代表的是有i个1，j个0的情况下，字符串最多的个数。<br>那么现在想想，dp代表的什么其实题目中已经很明确的告诉我们了，甚至还告诉了我们dp应该是几维的，怎么构造，以及vector的size是多少。所以每次编码之前都把这个问题想好答案。<br>/*题目描述<br>给定 m 个数字 0 和 n 个数字 1，以及一些由 0 - 1 构成的字符串，求利用这些数字最多可以构<br>成多少个给定的字符串，字符串只可以构成一次。<br>输入输出样例<br>输入两个整数 m 和 n，表示 0 和 1 的数量，以及一个一维字符串数组，表示待构成的字符串；<br>输出是一个整数，表示最多可以生成的字符串个数。<br>Input : Array = { “10”, “0001”, “111001”, “1”, “0” }, m = 5, n = 3<br>Output : 4<br>在这个样例中，我们可以用 5 个 0 和 3 个 1 构成[“10”, “0001”, “1”, “0”]。<br>*/</p><p>#include <iostream><br>#include<vector><br>#include<cmath><br>#include&lt;math.h&gt;<br>using namespace std;<br>int max(int a, int b);<br>pair&lt;int, int&gt;count(const string&amp; str)<br>{<br>    int count0 = 0, count1 = 0;<br>    for (int i = 0; i &lt; str.size(); i++)<br>    {<br>        if (str[i] == ‘1’)count1++;<br>        if (str[i] == ‘0’)count0++;<br>    }<br>    pair&lt;int, int&gt;x(count0, count1);<br>    return x;<br>    //return make_pair(count0,count1);<br>}</cmath></vector></iostream></p><p>//dp代表的是什么，在有m个1，n个0的情况下，最多的字符串。自己写的<br>/<em>int abc(vector<string>&amp; nums, int m, int n)<br>{<br>    vector&lt;vector<int>&gt;dp(m+1,vector<int>(n+1,0));<br>    for (const string&amp;str: nums)<br>    {<br>        auto [count0, count1] = count(str);<br>        for (int i = m, int j = n; i &gt;=count0&amp;&amp;j&gt;=count1;i–,j– )<br>        {<br>            dp[i][j] = max(dp[i - count0][j - count1] + 1, dp[i][j]);<br>        }<br>    }<br>}</int></int></string></em>/<br>//下面是参考代码<br>int lc474(vector<string>&amp; nums, int m, int n)<br>{<br>    vector&lt;vector<int>&gt;dp(m + 1, vector<int>(n + 1, 0));<br>    int count0, count1;<br>    for (const string&amp; str : nums)<br>    {<br>        pair&lt;int, int&gt; x(count0, count1);<br>        x= count(str);<br>        count0 = x.first;<br>        count1 = x.second;<br>        for (int i = m; i &gt;= count0 ; i–)<br>            for(int j=n;j&gt;=count1;j–)<br>                dp[i][j] = max(dp[i - count0][j - count1] + 1, dp[i][j]);<br>    }<br>    return  dp[m][n];<br>}</int></int></string></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo搭建博客中可能遇到的问题</title>
    <link href="/2021/04/15/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%8F%AF%E8%83%BD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2021/04/15/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%8F%AF%E8%83%BD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>1.StackOverflow是个好东西啊，善于利用它，就在刚刚它解决了困扰了我一天的问题，我说怎么新版本总是传不上去，原来是git版本太低了，真是未曾设想的错误。所以在搭建过程中如果是git bash总给你报各种各样的上传错误的话，很有可能是git的版本问题，当然了，具体什么情况把错误信息放到StackOverflow上问一下就好了。<br>2.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>真正意义上的第一篇博客</title>
    <link href="/2021/04/15/%E7%9C%9F%E6%AD%A3%E6%84%8F%E4%B9%89%E4%B8%8A%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/04/15/%E7%9C%9F%E6%AD%A3%E6%84%8F%E4%B9%89%E4%B8%8A%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>从昨天晚上七点逛各位互联网技术大佬的博客，到自己受启发决定搭建博客，再到刚刚终于将整个博客加主题搭好恰恰花了一天的时间。在这里发自内心的说一句，搭环境真的不是人干的事。但总归还是学到一些东西的，在此列举一下<br>1.昨天晚上其实就已经把一个简陋博客搭好了，但是由于配置问题css和js文件一直加载不出来（这个是今天困扰了我一天的问题）。由于是把博客托管给GitHub，在搭建的过程中避不开git管理仓库，所以昨天误打误撞的把git管理学了个大概（博客搭得不知道怎么样，反倒是把git给学了一些。笑）<br>2.知道了网页出问题要首先看一下浏览器f12里面的console运行情况<br>3.以及学会了怎么配置一些基本的博客上的小东西，具体请看hexo官方文档上有关_config.yml的介绍。<br>  本来今天早上看到有人说自己造了一个博客项目，自己看的热血沸腾，雄心壮志的准备也从零开始搞一个博客框架，幸好及时的认清自己的实力，作罢。<br>  搭建自己的博客也是受好友启发，前几日好友开通小红书记录生活，目的悦己。觉得很不错，又考虑到自己的专业，遂决定弄一个什么记录生活的东西出来，昨天逛技术博客，便水到渠成想到了博客。<br>  目前这个博客主题我想好了，就叫《代码与诗》，听起来就很文（装）艺（逼）哈哈哈哈哈哈。解释一下就是更新一些技术上的问题和解决方法，以及一些古诗和音乐上的感悟。<br>  第一篇技术博客我也已经想好了，就是搞了我一天的这个搭建博客过程中遇到的一些问题。<br>  讲道理，这些搭环境，装系统的事情真的是烦的很，且不和你的专业能力呈线性相关，你不知道这个东西就是不知道，有时候真的就是玄学，也有时候你根本不知道在什么地方会出什么样的错。网上的教程又大多数时候只是授之以鱼，背后稍微深层次的东西都讲不出来。顺便在这里祝自己早日丢掉在csdn这个垃圾桶里翻东西的习惯，翻得久了多少也会沾上一些臭味。<br>  就到这吧，该刷leetcode了，一天没刷了，这周日就要考试。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>have a try</title>
    <link href="/2021/04/15/have-a-try/"/>
    <url>/2021/04/15/have-a-try/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>article title</title>
    <link href="/2021/04/15/article-title/"/>
    <url>/2021/04/15/article-title/</url>
    
    <content type="html"><![CDATA[<p>希望能过</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
