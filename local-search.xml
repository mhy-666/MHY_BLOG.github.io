<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>动态规划之状态转移方程应用</title>
    <link href="/2021/04/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B%E5%BA%94%E7%94%A8/"/>
    <url>/2021/04/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>今天对于状态转移方程有了自己的一些理解，下面这道题就是自己亲手写出来的，怎么说呢，感觉还是蛮自豪的。<br>/*<br>给定一些硬币的面额，求最少可以用多少颗硬币组成给定的金额。<br>输入输出样例<br>输入一个一维整数数组，表示硬币的面额；以及一个整数，表示给定的金额。输出一个整数，<br>表示满足条件的最少的硬币数量。若不存在解，则返回 - 1。<br>Input : coins = [1, 2, 5], amount = 11<br>Output : 3<br>在这个样例中，最少的组合方法是 11 = 5 + 5 + 1。<br><em>/<br>#include <iostream><br>#include<vector><br>#include<cmath><br>#include&lt;math.h&gt;<br>using namespace std;<br>//首先，dp[j]代表的是在给定金额为j的情况之下，所用的最少硬币数。<br>//显然，这是一个完全背包问题，构造dp为一维数组，内层选择从左到右迭代（正序）<br>int min(int a, int b)<br>{<br>    if (a &gt;= b)return b;<br>    else return a;<br>}<br>int lc322(vector<int>&amp;coins,int amount)<br>{<br>    vector<int>dp(amount+1, 10000);<br>    dp[0] = 0;<br>    for (const int&amp; i : coins)<br>    {<br>        for (int j = i; j &lt;= amount; j++)<br>        {<br>            dp[j] = min(dp[j], dp[j - i] + 1);<br>        }<br>    }<br>    return dp[amount];<br>}<br>/*int main()<br>{<br>    int n, amount;<br>    cin &gt;&gt; n &gt;&gt; amount;<br>    vector<int>coins(n, 0);<br>    for (int i = 0; i &lt; n; i++)<br>    {<br>        cin &gt;&gt; coins[i];<br>    }<br>    cout&lt;&lt;lc322(coins, amount);<br>}</int></int></int></cmath></vector></iostream></em>/</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>自制（手抄）操作系统--xv6学习笔记前言</title>
    <link href="/2021/04/20/%E8%87%AA%E5%88%B6%EF%BC%88%E6%89%8B%E6%8A%84%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%89%8D%E8%A8%80/"/>
    <url>/2021/04/20/%E8%87%AA%E5%88%B6%EF%BC%88%E6%89%8B%E6%8A%84%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%89%8D%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<p>  发现自己一直以来的学习都有一个矛盾：动手的时候发现理论知识不太会，告诫自己不要好高骛远，先沉下心来钻研基础理论；等开始钻研基础理论时，又发现自己怎么也不能深入理解，并且学过就忘，又想起警世格言“learning by doing（coding/programing）”，遂又反过头来继续动手操作。如此反复，陷入一个奇妙的恶性循环，现在想来，我愿称这种学习为“混沌学习理论”。这样的学习方法蕴含的思想对吗，很难说不对；有效吗，很难称得上有效，尤其是这样的学习方法让自己感到持久性的痛苦和持久性的生理不适。那么，问题出在了哪里呢？我今天顿悟：理论与实践切换周期过长，切换频率过慢。什么意思，简而言之，就是字面理解，在各自方面投入的学习时间过长，没有把握好一个完整的理论+实践学习的周期。话说到这里，解决方法也就显而易见，加快切换速度，缩短切换周期呗。<br>  以为这样就完了吗，并没有。怎么分配呢，是平均吗，我觉得不是，至少在现在的我，在今天的我看来不是（毕竟还没有真正付诸实践）。我认为在入门阶段应该重动手，轻理论。入门之后的事情我也没接触到，不好说。注意，这里我指的是学习任意一门知识，都是按照这样来入门。<br>  总之今天就先这样，要开始做xv6的实验了，在实践过程中再有什么新的感悟或者修正再讲吧。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于背包问题及其拓展应用</title>
    <link href="/2021/04/19/%E5%85%B3%E4%BA%8E%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95%E5%BA%94%E7%94%A8/"/>
    <url>/2021/04/19/%E5%85%B3%E4%BA%8E%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>背包问题是一个经典的动态规划问题。分为完全背包和01背包。每一种背包对应着两种解法，时间复杂度和空间复杂度分别为&lt;o(nw),o(nw)&gt;和&lt;o(nw),o(w)&gt;，可见差异在于空间复杂度。造成差异的原因是dp容器后者比前者少了一个维度。此外，两种背包问题它们后一种解法各自的迭代顺序不同；前一种解法的状态转移方程不同。以上就是两种背包问题本身的所有差异以及各自对应的两种解法的所有差异。<br>从个人来讲，我不喜欢第一种解法（不论是哪种背包问题），因为宏观上状态转移方程很好理解，但是for循环过程不好理解。我更喜欢后一种，既降低了空间复杂度，也在过程中更容易理解。以下是三种解法，前两个是01背包问题的第一第二解法，第三种是完全背包问题的第二解法。顺带一提，完全背包问题的第一解法的状态转移方程为dp[i][j]=max(dp[i-1][j],dp[i][j-w]+v)</p><p>// 背包问题.cpp : 此文件包含 “main” 函数。程序执行将在此处开始并结束。<br>//</p><p>#include <iostream><br>#include <vector><br>#include <cmath><br>#include &lt;math.h&gt;<br>using namespace std;<br>int max(int a, int b)<br>{<br>    if (a &gt;= b)return a;<br>    else return b;<br>}<br>void knapback(int N,int W,vector<int>&amp;value,vector<int>&amp; weight)<br>{</int></int></cmath></vector></iostream></p><pre><code>vector&lt;vector&lt;int&gt;&gt;dp(N+1, vector&lt;int&gt;(W+1,0));for (int i = 1; i &lt;= N; i++)&#123;    int w = weight[i];    int v = value[i];    for (int j = 1; j &lt;= W; j++)    &#123;        if (j &gt; w)            dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w] + v);        else            dp[i][j] = dp[i - 1][j];    &#125;&#125;cout &lt;&lt; dp[N][W];</code></pre><p>}<br>void knapback_2(int N, int W, vector<int>&amp; value, vector<int>&amp; weight)<br>{<br>    vector<int>dp(W + 1,  0);<br>    for (int i = 1; i &lt;= N; i++)<br>    {<br>        int w = weight[i]; int v = value[i];<br>        for (int j = W; j &gt;= w; j–)<br>        {<br>            dp[j] = max(dp[j], dp[j - w] + v);<br>        }<br>    }<br>    cout &lt;&lt; dp[W];<br>}</int></int></int></p><p>void knapback_3(int N, int W, vector<int>&amp; value, vector<int>&amp; weight)//完全背包问题<br>{<br>    vector<int>dp(W + 1, 0);<br>    for (int i = 1; i &lt;= N; i++)<br>    {<br>        int w = weight[i]; int v = value[i];<br>        for (int j = w; j &lt;= W; j++)<br>        {<br>            dp[j] = max(dp[j], dp[j - w] + v);<br>        }<br>    }<br>    cout &lt;&lt; dp[W];<br>}<br>/*测试用例<br>34 10<br>2 7 3 4 8 5 8 6 4 16<br>15 25 8 9 15 9 13 9 6 14<br>34 10<br>2 8 4 4 8 7 8  5 16 16<br>15 25 9 9 15 12 12 6 14 9*/<br>int main()<br>{<br>    int W, N;<br>    cin &gt;&gt; W &gt;&gt; N;<br>    vector<int> weight(N + 1);<br>    vector<int> value(N + 1);<br>    for (int i = 1; i &lt;= N; i++)<br>    {<br>        cin &gt;&gt; weight[i];</int></int></int></int></int></p><pre><code>&#125;for (int i = 1; i &lt;= N; i++)&#123;    cin &gt;&gt; value[i];&#125;knapback_3(N,W,value,weight);</code></pre><p>}<br>这里面有一些自己在编程过程中犯的错误，还有一些技巧。<br>1.N+1,W+1<br>这里将vector的大小设为+1是因为更好的理解，以后自己也尽量不要去考虑0号元素，认为它是空就好了，同时编码的时候要注意for循环i的初始值和结束值。<br>2.vector的赋值问题<br>3.完全背包问题第二解法更新dp是正序遍历，为了是能够将平均价值最多的物品找出来。<br>4.01背包问题的第一解法内层循环分为j&gt;=w和j&lt;w两种情况，j&lt;w时直接把上一个i-1的dp赋值过去就好</p><p>自己还有一些疑惑，比如完全背包问题直接找平均价值最高的物品不就好了吗，为什么要这么麻烦？</p><p>#pragma once<br>/<em>题目描述<br>给定一个正整数数组，求是否可以把这个数组分成和相等的两部分。<br>输入输出样例<br>输入是一个一维正整数数组，输出时一个布尔值，表示是否可以满足题目要求。<br>Input : [1, 5, 11, 5]<br>Output : true<br>在这个样例中，满足条件的分割方法是[1, 5, 5] 和[11]。</em>/</p><p>#include <iostream><br>#include<vector><br>#include<cmath><br>#include&lt;math.h&gt;<br>using namespace std;<br>bool if416(vector<int>&amp;number,int n)<br>{</int></cmath></vector></iostream></p><pre><code>int target=0;for (int i = 1; i &lt; number.size(); i++)&#123;    target += number[i];&#125;if (target % 2)return false;target = target / 2;vector&lt;int&gt;dp(target + 1, 0);dp[0] = 1;for (int i = 1; i &lt;= n; i++)&#123;    int v = number[i];    for (int j = target; j &gt;= v; j--)    &#123;        dp[j] = dp[j] || dp[j - v];    &#125;&#125;cout &lt;&lt; dp[target];</code></pre><p>}<br>/*<br>4<br>1 5 5 11<br>*/</p><p>经过了这道题，我想试着总结一下背包问题的应用，或者说是神奇之处：它可以把n个有重量物品中任意x个物品的属性组合在一起，并把所有组合情况都遍历一遍。背包也好，上面这道题也好，所求的其实都是在某种重量约束下这些组合属性的限制条件，比如背包就是x个有重量物品，属性为价值，重量约束为不超过w，限制条件是x个物品的属性最大，dp为最大价值，过程为从0到w的所有最大价值。再比如上面这道题，就是x个有大小（重量）的数（物品），没有属性，重量约束为等于target，dp为真假，过程为从0到target的所有真假。</p><p>——-4.20补充<br>一定要知道自己构造的dp到底代表的什么，比如背包问题，dp[i][j]代表的是对于遍历到第i个物品时，背包所容纳的重量不超过j的情况下装入物品的最大价值，而第二解法的dp[j]则代表背包所容纳的重量不超过i的情况下装入物品的最大价值。再比如417，dp[j]代表的是是否存在和为j的情况。<br>下面这道题，dp[i][j]代表的是有i个1，j个0的情况下，字符串最多的个数。<br>那么现在想想，dp代表的什么其实题目中已经很明确的告诉我们了，甚至还告诉了我们dp应该是几维的，怎么构造，以及vector的size是多少。所以每次编码之前都把这个问题想好答案。<br>/*题目描述<br>给定 m 个数字 0 和 n 个数字 1，以及一些由 0 - 1 构成的字符串，求利用这些数字最多可以构<br>成多少个给定的字符串，字符串只可以构成一次。<br>输入输出样例<br>输入两个整数 m 和 n，表示 0 和 1 的数量，以及一个一维字符串数组，表示待构成的字符串；<br>输出是一个整数，表示最多可以生成的字符串个数。<br>Input : Array = { “10”, “0001”, “111001”, “1”, “0” }, m = 5, n = 3<br>Output : 4<br>在这个样例中，我们可以用 5 个 0 和 3 个 1 构成[“10”, “0001”, “1”, “0”]。<br>*/</p><p>#include <iostream><br>#include<vector><br>#include<cmath><br>#include&lt;math.h&gt;<br>using namespace std;<br>int max(int a, int b);<br>pair&lt;int, int&gt;count(const string&amp; str)<br>{<br>    int count0 = 0, count1 = 0;<br>    for (int i = 0; i &lt; str.size(); i++)<br>    {<br>        if (str[i] == ‘1’)count1++;<br>        if (str[i] == ‘0’)count0++;<br>    }<br>    pair&lt;int, int&gt;x(count0, count1);<br>    return x;<br>    //return make_pair(count0,count1);<br>}</cmath></vector></iostream></p><p>//dp代表的是什么，在有m个1，n个0的情况下，最多的字符串。自己写的<br>/<em>int abc(vector<string>&amp; nums, int m, int n)<br>{<br>    vector&lt;vector<int>&gt;dp(m+1,vector<int>(n+1,0));<br>    for (const string&amp;str: nums)<br>    {<br>        auto [count0, count1] = count(str);<br>        for (int i = m, int j = n; i &gt;=count0&amp;&amp;j&gt;=count1;i–,j– )<br>        {<br>            dp[i][j] = max(dp[i - count0][j - count1] + 1, dp[i][j]);<br>        }<br>    }<br>}</int></int></string></em>/<br>//下面是参考代码<br>int lc474(vector<string>&amp; nums, int m, int n)<br>{<br>    vector&lt;vector<int>&gt;dp(m + 1, vector<int>(n + 1, 0));<br>    int count0, count1;<br>    for (const string&amp; str : nums)<br>    {<br>        pair&lt;int, int&gt; x(count0, count1);<br>        x= count(str);<br>        count0 = x.first;<br>        count1 = x.second;<br>        for (int i = m; i &gt;= count0 ; i–)<br>            for(int j=n;j&gt;=count1;j–)<br>                dp[i][j] = max(dp[i - count0][j - count1] + 1, dp[i][j]);<br>    }<br>    return  dp[m][n];<br>}</int></int></string></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo搭建博客中可能遇到的问题</title>
    <link href="/2021/04/15/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%8F%AF%E8%83%BD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2021/04/15/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%8F%AF%E8%83%BD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>1.StackOverflow是个好东西啊，善于利用它，就在刚刚它解决了困扰了我一天的问题，我说怎么新版本总是传不上去，原来是git版本太低了，真是未曾设想的错误。所以在搭建过程中如果是git bash总给你报各种各样的上传错误的话，很有可能是git的版本问题，当然了，具体什么情况把错误信息放到StackOverflow上问一下就好了。<br>2.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>真正意义上的第一篇博客</title>
    <link href="/2021/04/15/%E7%9C%9F%E6%AD%A3%E6%84%8F%E4%B9%89%E4%B8%8A%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/04/15/%E7%9C%9F%E6%AD%A3%E6%84%8F%E4%B9%89%E4%B8%8A%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>从昨天晚上七点逛各位互联网技术大佬的博客，到自己受启发决定搭建博客，再到刚刚终于将整个博客加主题搭好恰恰花了一天的时间。在这里发自内心的说一句，搭环境真的不是人干的事。但总归还是学到一些东西的，在此列举一下<br>1.昨天晚上其实就已经把一个简陋博客搭好了，但是由于配置问题css和js文件一直加载不出来（这个是今天困扰了我一天的问题）。由于是把博客托管给GitHub，在搭建的过程中避不开git管理仓库，所以昨天误打误撞的把git管理学了个大概（博客搭得不知道怎么样，反倒是把git给学了一些。笑）<br>2.知道了网页出问题要首先看一下浏览器f12里面的console运行情况<br>3.以及学会了怎么配置一些基本的博客上的小东西，具体请看hexo官方文档上有关_config.yml的介绍。<br>  本来今天早上看到有人说自己造了一个博客项目，自己看的热血沸腾，雄心壮志的准备也从零开始搞一个博客框架，幸好及时的认清自己的实力，作罢。<br>  搭建自己的博客也是受好友启发，前几日好友开通小红书记录生活，目的悦己。觉得很不错，又考虑到自己的专业，遂决定弄一个什么记录生活的东西出来，昨天逛技术博客，便水到渠成想到了博客。<br>  目前这个博客主题我想好了，就叫《代码与诗》，听起来就很文（装）艺（逼）哈哈哈哈哈哈。解释一下就是更新一些技术上的问题和解决方法，以及一些古诗和音乐上的感悟。<br>  第一篇技术博客我也已经想好了，就是搞了我一天的这个搭建博客过程中遇到的一些问题。<br>  讲道理，这些搭环境，装系统的事情真的是烦的很，且不和你的专业能力呈线性相关，你不知道这个东西就是不知道，有时候真的就是玄学，也有时候你根本不知道在什么地方会出什么样的错。网上的教程又大多数时候只是授之以鱼，背后稍微深层次的东西都讲不出来。顺便在这里祝自己早日丢掉在csdn这个垃圾桶里翻东西的习惯，翻得久了多少也会沾上一些臭味。<br>  就到这吧，该刷leetcode了，一天没刷了，这周日就要考试。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>have a try</title>
    <link href="/2021/04/15/have-a-try/"/>
    <url>/2021/04/15/have-a-try/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>article title</title>
    <link href="/2021/04/15/article-title/"/>
    <url>/2021/04/15/article-title/</url>
    
    <content type="html"><![CDATA[<p>希望能过</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
